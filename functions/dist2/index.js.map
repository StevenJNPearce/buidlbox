{"version":3,"sources":["../src/index.js"],"names":["URL","require","uport","uuid","ethers","express","admin","functions","cors","origin","db","Credentials","SimpleSigner","serviceAccount","databaseURL","uportSimpleSigner","uportCredentials","appName","address","signer","networks","initializeApp","credential","cert","firestore","exports","identity","https","onRequest","request","response","body","JWT","receive","then","profile","name","auth","updateUser","displayName","avatar","photoURL","uri","createCustomToken","json","customToken","send","databaseWrite","writeType","branch","payload","catch","error","console","log","identityCallback","query","uid","access_token","UID","accessToken","attestationRequest","database","ref","onCreate","event","data","key","val","eventData","meta","status","type","loginGenerate","eventKey","attestationGenerate","createRequest","requested","input","notifications","callbackUrl","qr","requestToken","databaseSearch","boundaries","child","lookup","attest","sub","claim","pushToken","publicEncKey","push","url","attestation","message","err","authenticationComplete","user","providerData","providerId","eid","images","imageProfile","nameDisplay","nameFirst","contact","contactEmail","email","metadata","metadataAccountType","providerAccountType","provider","collection","add","person","transferToken","providers","InfuraProvider","Wallet","Contract","wallet","contract","transfer","sentToken","res","redirect"],"mappings":"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","file":"index.js","sourcesContent":["/* ------------------------ Node.js Dependencies ------------------------ */\nconst URL = require('url-parse');\n/* ------------------------ External Dependencies ------------------------ */\nconst uport = require('uport');\nconst uuid = require('uuid/v1');\nconst ethers = require('ethers');\nconst express =  require('express');\nconst admin = require('firebase-admin')\nconst functions = require('firebase-functions')\nconst cors = require('cors')({origin: true});\n/* ------------------------- Internal Dependencies -------------------------- */\nconst db = require('./database');\n\n// Constants\n// cors({origin: true});\nconst Credentials = uport.Credentials;\nconst SimpleSigner = uport.SimpleSigner;\nconst serviceAccount = require('../secrets/service_account.json')\nconst databaseURL = \"https://buidlbox-dev.firebaseio.com\"\n\n/**\n * uPort | Simple Signer\n * \n * The SimpleSigner key is reponsible for verifying decentralized applications.\n * In producion please add the SimpleSigner key as an envrionment variable.\n * \n * Example: firebase functions:config:set uport.simpleSigner='INSERT_KEY'  \n */\n// const uportSimpleSigner = functions.config().uport.simplesigner;\nconst uportSimpleSigner = SimpleSigner('d12d8a5c643ab7facc0a1815807aba1bed174762a2061b6b098b7bffd7462236')\n\nconst uportCredentials = new Credentials({\n  appName: 'Eidenai',\n  address: '2oo7fQjxR44MnKa8n4XKDZBBa2Buty4qrug',\n  signer: uportSimpleSigner,\n  networks: {'0x4': {'registry' : '0x2cc31912b2b0f3075a87b3640923d45a26cef3ee', 'rpcUrl' : 'https://rinkeby.infura.io'}}\n})\n\n/* ------------------------ Initialize Dependencies ------------------------- */\n/**\n * Firebase - Administrator Initialization\n */\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n  databaseURL: databaseURL\n});\nconst firestore = admin.firestore();\n\n/* -------------------------------------------------------------------------- */\n\n/* ------------------------ Firebase Cloud Functions ------------------------ */\n\n/* -------------------------------------------------------------------------- */\n\n/*---*---------------              ---------------*---* \n\n                  Identity Authentication\n\n/*---*---------------              ---------------*---*/\nexports.identity = functions.https.onRequest((request,response)=> {\n  cors(request, response, () => {\n    const JWT = request.body.JWT\n    uportCredentials.receive(JWT)\n    .then(profile => {\n      if(profile.name) admin.auth().updateUser(profile.address,{\n        displayName: profile.name\n      })\n      if(profile.avatar) admin.auth().updateUser(profile.address,{\n        photoURL: profile.avatar.uri\n      })\n      admin.auth().createCustomToken(profile.address)\n      .then(function(customToken) {\n        response.json(customToken).send()\n        db.databaseWrite({\n          writeType: 'update',\n          branch: [\"users\", profile.address, 'profile'],\n          payload: {\n            ...profile\n          },\n        })\n      })\n      .catch(function(error) {\n        response.send(error)\n        console.log(\"Error creating custom token:\", error);\n      });\n  })\n  .catch(function(error) {\n    response.send(error)\n    console.log(\"Error creating custom token:\", error);\n  });\n\n  })  \n})\n\n\n/**\n * Identity Callback\n * @desc Callback URL for the uPort Identity\n */\nexports.identityCallback = functions.https.onRequest((request,response)=> {\n  const UID = request.query.uid\n  const accessToken = request.body.access_token\n  db.databaseWrite({\n    writeType: 'update',\n    branch: [\"request\", 'login', UID, 'data'],\n    payload: {\n      JWT: accessToken\n    },\n  })\n})\n\n/*---*---------------              ---------------*---* \n\n                    Database Requests \n\n/*---*---------------              ---------------*---*/\n\n/**\n * Manage Attestation Requests\n * \n * TODO(@kamescg): Better Attestation Verification database naming structure.\n * \n * Currently the '/request/attestation/' path is montired for database changes.\n * This is just a starting point and MVP for data streaming between frontend/backend\n *  \n * The process needs to be more thoroughly thought about to fully understand how we\n * can enable as many verifiatons systems to \"hook\" into our private verification attestation\n * framework/boilerplate. \n */\n\nexports.attestationRequest = functions.database.ref('/request/{type}/{request}')\n  .onCreate(event => {\n    const eventKey = event.data.key \n    const eventData = event.data.val()\n    if(eventData.meta.status) {\n      switch(eventData.meta.status) {\n        case('initialized'):\n          switch(eventData.meta.type) {\n            case('login'):\n            return loginGenerate(eventData, eventKey)\n            case('attestation'):\n            return attestationGenerate(eventData, eventKey)\n          }\n        default:\n        // TODO(@kamescg): Handle default use case. \n        break;\n      }\n    }\n  })\n\n\nconst loginGenerate = (eventData, eventKey) => {\n  return uportCredentials.createRequest({\n    requested: eventData.input.requested,\n    notifications: eventData.input.notifications,\n    callbackUrl: `https://us-central1-buidlbox-dev.cloudfunctions.net/identityCallback?uid=${eventKey}`\n  }).then(requestToken => {\n    db.databaseWrite({\n      writeType: 'update',\n      branch: [\"request\", 'login', eventKey],\n      payload: {\n        data: {\n          qr: `me.uport:me?requestToken=${requestToken}`\n        },\n        meta: {\n          status: 'requested',\n          type: 'login'\n        }\n      },\n    })\n  })\n}\n\n const attestationGenerate = (eventData, eventKey) => {\n  console.log(eventData)\n  return db.databaseSearch({\n    branch: [\"users\"],\n    boundaries: {\n      child: eventData.meta.uid\n    },\n  }).then(lookup=>{\n    console.log(lookup)\n    uportCredentials.attest({\n      sub: lookup[0].address,\n      claim: {\n        ...eventData.data\n      }\n    }).then(attestation=>{\n      console.log(lookup[0].pushToken)\n      console.log(lookup[0].publicEncKey)\n      const message = \"Hello Kames\"\n      const url =  `me.uport:add?attestations=${attestation}`\n      uportCredentials.push(lookup[0].pushToken, lookup[0].publicEncKey, {url, message}).then(response => {\n        console.log(response)\n      })\n\n        // db.databaseWrite({\n        //   config: {writeType: 'update'},\n        //   entity: 'users',\n        //   branch: [\"request\", 'attestation', eventKey],\n        //   payload: {\n        //     ...eventData,\n        //     admin: {\n        //       attestation: `me.uport:add?attestations=${attestation}`, // TODO(@kamescg) Update this JWT generation using Zach's new libraries.\n        //       issued: true\n        //     }\n        //   },\n        // })\n\n    }).catch(err=>console.log(err))\n})\n } \n\n\n\n\n/*---*---------------              ---------------*---* \n\n                      Authentication \n\n/*---*---------------              ---------------*---*/\nexports.authenticationComplete = functions.auth.user().onCreate(event => {\n\n  const providerAccountType = {\n    \"google.com\": 'google',\n    \"github.com\": 'github',\n    \"twitter.com\": 'twitter',\n    \"facebook.com\": 'facebook',\n  }[event.data.providerData.providerId]\n\n  const person = {\n    eid: event.data.uid,\n    images: {\n      imageProfile: event.data.photoURL\n    },\n    name: {\n      nameDisplay: event.data.displayName,\n      nameFirst: event.data.displayName,\n    },\n    contact: {\n      contactEmail: event.data.email,\n    },\n    metadata: {\n      metadataAccountType: providerAccountType || false\n    },\n    provider: event.data.providerData,\n  }\n  firestore.collection('people').add(person)\n\n});\n\n/*---*---------------              ---------------*---* \n\n                     Ethereum Signing \n\n/*---*---------------              ---------------*---*/\n/* TODO (@siunami): Currently everything is hardcoded\n\ninfuraProviderKey: need to supply infura provider key\nprivateKeyOfSender: privateKey of signer\nsendTokenTo: address to send token to\nsentToken: hardcoded to send 1 token to same address. FUTURE: Will accept as request parameters\nmyContractABI, myContractAddress: for each contract\n\n*/\nexports.transferToken = functions.https.onRequest((req,res) => {\n  // Provided by user\n  var infuraProviderKey = '';\n  var privateKeyOfSender = '';\n  var sendTokenTo = '';\n  var numTokensToSend = 1;\n\n  var myContractABI = [];\n  var myContractAddress = \"\";\n\n  var provider = new ethers.providers.InfuraProvider('rinkeby',infuraProviderKey);\n  var wallet = new ethers.Wallet(privateKeyOfSender, provider);\n  var contract = new ethers.Contract(myContractAddress, myContractABI, wallet);\n\n  var sentToken = contract.transfer(sendTokenTo, numTokensToSend*100);\n  return sentToken.then(function(){\n    console.log(\"SUCCESS\");\n    return res.redirect(303, \"/\");\n  }).catch(function(err){\n    console.log(\"FAILURE\");\n    console.log(err);\n    return res.redirect(404, err);\n  })\n})\n\n"]}